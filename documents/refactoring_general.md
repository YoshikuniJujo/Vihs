リファクタリングに関する一般的な方針
====================================

はじめに
--------

もともとのコードを、「僕の好みに合うように」リファクタリングする。
「良い悪い」ではなく、完全に僕の好み、である。
原作者さんの参考になるとうれしい。

インデント
----------

これは完全に僕の好み。
8タブでタブによるインデントにする。
Haskellの世界では完全に異端。
これは、まねしないほうがいいだろう。
まねするなよ、絶対にまねするなよ。

複雑なコードはIOの外で
----------------------

できるだけ、複雑なことは、IOの外でやる。
IOを使うと入口や出口が複数になってしまい、
収集がつかなくなることが多い。

ループは切りわける
------------------

ループが必要なときは、1回だけの関数を使って、
ループとその本体とを切りわける。

main関数にも働かせる
--------------------

コマンドライン引数の処理や、
一度だけしかしない入出力などなどは、
main関数にも働いてもらう。
これは、関数のサイズを適切に保つうえで、有効。

アプリケーションの全体にわたって使われる変化する値はまとめる
------------------------------------------------------------

```haskell
data State = State { ... }
```

のようにして、アプリケーション全体で使う変化する値はまとめる。
また、このState値は、StateTを使うか、あるいは裸のままであるかを問わず、
関数の引数や返り値とする。
IORefなどでは変化させない。

複数のスレッドで同期が必要なときはChanを使う
--------------------------------------------

```haskell
Chan a
```

を利用して、同期させるのが、単純さを保てるので良いように思う。

モジュールにわける方針
----------------------

### 小さいうちはモジュールをわけない

将来のためにモジュールをわけておくというのも、ひとつの方法だが、
僕自身は、実際に大きくなるまでモジュールは、わけないという方針。

### 全体から独立させて変更したくなるだろう要素はわける

たとえば、将来的にパフォーマンスの関係で、
データ構造などを変更したくなるかもしれないときには、
モジュールにくくり出し、なかみと独立したインターフェースを定義する。

等値演算よりもパターンマッチを使う
----------------------------------

パターンマッチですむときに、等値演算は使わない。
もし必要ならばPatternGuardsを使うのも、ありかも。

importは修飾名をつけるか、importリストを明示する
------------------------------------------------

importについては、そのモジュールで何をインポートしているのかを明らかにするために、
修飾名をすけるか、importリストを明示する。

exportリストを明示する
----------------------

何をexportしているのかを明示する。

fromJustは使わない
------------------

テスト的な実装や、手抜きをしたいとき以外では、関数fromJustをはじめとする
「部分関数」は使わない。
